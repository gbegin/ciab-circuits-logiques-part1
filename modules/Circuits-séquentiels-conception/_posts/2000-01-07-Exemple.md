---
title: Exemple de conception
---

## Exemple de conception

On doit concevoir un circuit séquentiel qui détecte la séquence
binaire 101 lorsqu'elle apparaît dans sa séquence d'entrée. Une fois
la séquence identifiée, le système produira une sortie 1 et demeurera
dans le même état en continuant de produire une sortie 1, jusqu'à une
remise à zéro.

#### Diagramme d'état

 Selon le diagramme d'état de la figure [663](#orgfb2eb39), le
    système démarre dans l'état *a*, et demeure dans cet état tant que
    l'entrée $$A=0$$. Lorsque $$A=1$$, on passe à l'état *b*, début de la
    reconnaissance du patron 101. Ensuite, si $$A=1$$, on reste dans
    l'état *b* parce ce pourrait être le début d'une autre
    séquence 101. De l'état *b*, si $$A=0$$, on passe à l'état *c*, car on
    a observé 10 en séquence. De l'état *c*, si on a $$A=0$$, la séquence
    observée est maintenant de 100, et on doit tout recommencer en
    retournant à l'état *a*.  De l'état *c*, si on a $$A=1$$, alors on a
    reconnu la séquence 101. On met la sortie $$S=1$$ et on reste dans
    cet état pour toutes les autres transitions, quelle que soit
    l'entrée. Il s'agit ici d'une machine de Moore, puisque la sortie
    est $$S=1$$ produite lorsqu'on est dans l'état *d* ; on a $$S=0$$ dans
    les autres états.

![img]({{site.baseurl}}/img/seq_101_sanscode.svg "Diagramme d'état pour détecter la séquence 101")
*Diagramme d'état pour détecter la séquence 101*


#### Réduction d'état 

Il n'y a pas de réduction d'états possible.

#### Assigner des codes binaires aux états

Pour quatre états, il nous faudra deux bascules.  Le tableau [55](#orgc9da0ac) présente l'assignation d'états.

<table id="orgc9da0ac" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 46 :</span> Tableau d'assignation d'état</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">État</th>
<th scope="col" class="org-right">Code</th>
</tr>
</thead>

<tbody>
<tr>
<td class="org-left">a</td>
<td class="org-right">00</td>
</tr>


<tr>
<td class="org-left">b</td>
<td class="org-right">01</td>
</tr>


<tr>
<td class="org-left">c</td>
<td class="org-right">10</td>
</tr>


<tr>
<td class="org-left">d</td>
<td class="org-right">11</td>
</tr>

</tbody>
</table>

#### Compléter le tableau de transition

Le tableau [56](#org3ed7c99) donne les transitions d'états.

<table id="org3ed7c99" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 47 :</span> Tableau de transition d'états</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">$$ Z_1^n$$</th>
<th scope="col" class="org-right">$$ Z_0^n$$</th>
<th scope="col" class="org-right">$$ A$$</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">$$ Z_1^{n+1}$$</th>
<th scope="col" class="org-right">$$  Z_0^{n+1}$$</th>
<th scope="col" class="org-right">$$ S$$</th>
</tr>
</thead>

<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>


<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>


<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>


<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>


<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>


<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>


<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>


<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>

#### Sélectionner un type de bascules à utiliser.

On choisit des bascules D. 


#### Déterminer les expressions simplifiées 


Les diagrammes de Karnaugh correspondants sont donnés pour $$
Z_0^{n+1}$$ (figure [668](#org922f88a)), $$ Z_1^{n+1}$$ (figure
[668](#org922f88a)) et $$S$$ (figure [668](#org922f88a)).

![img]({{site.baseurl}}/img/diag-k_z0.png "Diag-K pour $$ Z_0^{n+1}$$")
*Diag-K pour  $$ Z_0^{n+1}$$*

![img]({{site.baseurl}}/img/diag-k_z1.png "Diag-K pour $$ Z_1^{n+1}$$")
*Diag-K pour $$ Z_1^{n+1}$$*

![img]({{site.baseurl}}/img/diag-k_S.png "Diag-K pour $$ S$$")
*Diag-K pour $$ S$$*

#### Décodeur de prochain état

Les expressions pour le décodeur de prochain état sont:

$$ Z_1^{n+1} = (A^\prime \cdot Z_0^{n}) + (A \cdot  Z_1^{n}) $$

$$ Z_0^{n+1} = A + (Z_0^{n} \cdot Z_1^{n}) $$

#### Décodeur de sortie

L'expression pour le décodeur de sortie est:

$$ S = Z_0^{n} \cdot Z_1^{n} $$

#### Schéma logique du circuit

Le circuit obtenu est représenté sur la figure
    [677](#org1516028). On montre sur la figure
    [678](#org693e108) une trace d'exécution. Les premiers coups
    d'horloge, l'entrée $$A=0$$ et le système demeure dans
    l'état 0. Puis, lorsque $$A=1$$, on passe à l'état 1. Comme $$A$$
    reste à 1, on demeure dans l'état 1 un certain temps. Puis, lorsque
    $$A=0$$, on passe à l'état 2. Avec $$A=1$$ de nouveau, on passe à
    l'état 3 en activant la sortie $$S=1$$. On ne quittera plus cet
    état ensuite. Une deuxième trace d'exécution (figure
    [679](#orgfec9ecd) ) montre un cas où le système retourne à
    l'état 0 après avoir reçu une séquence 100.

![img]({{site.baseurl}}/img/exemp_seq101_circ.svg "Détecteur pour la séquence 101")
*Détecteur pour la séquence 101*

![img]({{site.baseurl}}/img/exemp_seq101_trace1.svg "Trace d'exécution avec succès")
*Trace d'exécution avec succès*

![img]({{site.baseurl}}/img/exemp_seq101_trace2.svg "Trace d'exécution sans succès")
*Trace d'exécution sans succès*

